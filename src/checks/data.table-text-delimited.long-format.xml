<?xml version="1.0" encoding="UTF-8"?>
<mdq:check xmlns:mdq="https://nceas.ucsb.edu/mdqe/v1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://nceas.ucsb.edu/mdqe/v1 ../schemas/schema1.xsd">
  <id>data.table-text-delimited.long-format</id>
  <name>Check whether text delimited tables appear to be in long format.</name>
  <description>Well structured data tables should be "long" and not "wide." This check looks for repeated column name prefixes (eg: temp_1, temp_2, ...) as a signal for wide data structures.</description>
  <type>Reusable</type>
  <level>OPTIONAL</level>
  <environment>python</environment>
  <code><![CDATA[

def call():
    global output
    global status
    global output_identifiers
    global output_type
    global metadigpy_result

    from metadig import StoreManager
    from metadig import metadata as md
    from collections import Counter
    import pandas as pd
    import io
    import re
    import gc

    manager = StoreManager(storeConfiguration)  

    output_data = []
    status_data = []
    output_identifiers = []
    output_type = []
    metadigpy_result = {}

    if not dataPids or len(dataPids) == 0:
      output_data = "No data objects found."
      output_type = "text"

    for pid in dataPids:
        output_identifiers.append(pid)

        # If data object is not available, skip the pid.
        try:
            # if file is not text/csv, skip it
            # otherwise get the object and filename
            obj, fname, csv_status = md.get_valid_csv(manager, pid)
            if csv_status == "SKIP":
                output_data.append(f"`{fname}` is not a text-delimited table, skipping.")
                output_type.append("markdown")
                status_data.append(csv_status)
                continue
        except Exception as e:
            output_data.append(f"Unexpected Exception: {e}")
            output_type.append("markdown")
            status_data.append("FAILURE")
            continue

        # Ensure that the data object is documented in the list of entity names
        entity_index = md.find_entity_index(fname, pid, entityNames, ids)
        if entity_index is None:
            output_data.append(f"`{fname}` does not appear to be documented in the metadata.")
            output_type.append("markdown")
            status_data.append("FAILURE")
            continue

        # Set the default expecated header line value (the first row is headers)
        num_header_lines = 0
        # headerLines represents 'numHeaderLines' which is retrieved from the EML document
        if isinstance(headerLines, list):
            # If we successfully retrieve a list, we will check what the value is
            header_line_value = headerLines[entity_index]
            if header_line_value is None or str(header_line_value).lower() == 'null':
                # No header lines specified
                pass
            elif isinstance(header_line_value, (int, float)):
                # convert float to int
                num_header_lines = int(header_line_value)
            else:
                # try to parse numeric strings
                try:
                    num_header_lines = int(float(header_line_value))
                except (ValueError, TypeError):
                    pass
        
        # Try to read the data object
        obj_bytes_read = obj.read()
        encoding_type, enc_msg = md.detect_text_encoding(obj_bytes_read)
        d_read_decoded = obj_bytes_read.decode(encoding_type)
        df, error = md.read_csv_with_metadata(d_read_decoded, fieldDelimiter[entity_index], num_header_lines, encoding_type, nan_filter = False, dtype_string = True)
        if error:
            output_data.append(f"`{fname}`is unable to be read as a table. {error}")
            output_type.append("markdown")
            status_data.append("FAILURE")
            continue

        # cleanup
        del obj_bytes_read

        # Check for non-printable characters
        column_names = df.columns
        prefixes = [re.split(r"[_-]", col, maxsplit=1)[0] for col in column_names]
        pref_counts = Counter(prefixes)

        if any(count > 3 for count in pref_counts.values()):
            pref_repeat = [key for key,value in pref_counts.items() if value > 3]
            output_data.append(f"`{fname}` contains the following repeated column name prefixes: `{', '.join(pref_repeat)}`, and might be in wide format.")
            status_data.append("FAILURE")
        else:
            output_data.append(f"`{fname}` appears to be in long format.")
            output_type.append("markdown")
            status_data.append("SUCCESS")

        # cleanup
        del df
        gc.collect()

    successes = sum(x == "SUCCESS" for x in status_data)
    failures = sum(x == "FAILURE" for x in status_data)
    skips = sum(x == "SKIP" for x in status_data)
    output = output_data
    if failures > 0:
        status = "FAILURE"
    elif all(s == "SKIP" for s in status_data):
        status = "SKIP"
    else:
        status = "SUCCESS"

    metadigpy_result["identifiers"] = output_identifiers
    metadigpy_result["output"] = output_data
    metadigpy_result["status"] = status
    return True

  ]]></code>
  <selector>
    <name>entityNames</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
    <subSelector>
      <name>...</name>
      <xpath>./entityName</xpath>
    </subSelector>
  </selector>
  <selector>
    <name>ids</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]/@id</xpath>
  </selector>
  <selector>
     <name>fieldDelimiter</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
     <subSelector>
        <name>...</name>
        <xpath>./physical/dataFormat/textFormat/simpleDelimited/fieldDelimiter</xpath>
    </subSelector>
  </selector>
  <selector>
     <name>headerLines</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
     <subSelector>
        <name>...</name>
        <xpath>./physical/dataFormat/textFormat/numHeaderLines</xpath>
    </subSelector>
  </selector>
  <dialect>
    <name>Ecological Metadata Language</name>
    <xpath>boolean(/*[local-name() = 'eml'])</xpath>
  </dialect>
</mdq:check>
