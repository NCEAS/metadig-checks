<?xml version="1.0" encoding="UTF-8"?>
<mdq:check xmlns:mdq="https://nceas.ucsb.edu/mdqe/v1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="https://nceas.ucsb.edu/mdqe/v1 ../schemas/schema1.xsd">
  <id>data.table-text-delimited.variables-congruent</id>
  <name>Text delimited table variables names congruent</name>
  <description>Check that text delimited table variables names are congruent.</description>
  <type>identification</type>
  <level>REQUIRED</level>
  <environment>rscript</environment>
  <code><![CDATA[

    library(metarake)
    library(metadig)
    library(EML)
    
    result <- list()
    
    sys <- parse_system_metadata(systemMetadata)

    if (grepl("test", sys@authoritativeMemberNode, ignore.case = TRUE)){
      options(dataone_test_token = Sys.getenv("DATAONE_AUTH_TOKEN"))
    } else {
      options(dataone_token = Sys.getenv("DATAONE_AUTH_TOKEN"))
    }
  
    doc <- read_eml(document)
    data_pids <- get_data_pids(sys@identifier, sys@authoritativeMemberNode)
    data_pids <- data_pids[which(data_pids != sys@identifier)]
    authNode <- sys@authoritativeMemberNode
    if (length(data_pids) > 100){
      file_num = 100
    } else {
      file_num = length(data_pids)
    }
    if (length(data_pids) > 0){
      for (i in 1:file_num){
        
        data_obj <- tryCatch({
          get_data_file(authNode, data_pids[i])
        },
        error = function(e) {
          e
        })
        
        if (inherits(data_obj, "error")) {
          result[[i]] <- list(status = "ERROR")
          save_output(paste("Something went wrong when trying to download ", data_pids[i], ":", data_obj))
          next
        }
        
        sys_d <- data_obj@sysmeta
        
        fname <- sys_d@fileName
        fpath <- tempfile(fname)
        writeBin(data_obj@data, fpath)
        
        if (!(sys_d@formatId %in% c("text/tsv", "text/csv"))){
          result[[i]] <- list(status = "SUCCESS")
          save_output(paste(fname, "does not appear to be documented as a text-delimited table."))
          next
        }
        
        z <- which(entityNames == fname)
        if (length(z) == 0){
          z <- which(objectNames == fname)
        }
        if (length(z) == 0){
          id <- gsub(":", "-", sys@identifier)
          z <- which(ids == id)
        }
        if (length(z) == 0){
          result[[i]] <- list(status = "FAILURE")
          save_output(paste(fname, "is not documented in the metadata."))
          next
        }
        
        ent <- find_eml_entity(doc, sys_d@identifier, sys_d@fileName)
        
        df <- read_text_file(fpath, fieldDelimiter[z], headerLines[z])
        if (is.null(df)) {
          result[[i]] <- list(status = "ERROR")
          save_output(paste(fname[i], "could not parse."))
          next
        }
        
        att_names <- eml_get_simple(ent, "attributeName")
        
        if (all(att_names == names(df))){
          status <- TRUE
        } else {
          status <- FALSE
        }
        
        if (!status){
          result[[i]] <- list(status = "FAILURE")
          save_output(paste(fname, "variable names do not match documented variables."))
        } else if (status){
          result[[i]] <- list(status = "SUCCESS")
          save_output(paste(fname, "variable names match documented variables."))
        }
      }
      
      statuses <- unlist(lapply(result, function(x){x$status}))
      
      failures <- length(which(statuses == "FAILURE"))
      errors <- length(which(statuses == "ERROR"))
      successes <- length(which(statuses == "SUCCESS"))
      
      output_string <- paste(successes, "file(s) with complete variable documentation.",
                             failures, "file(s) with variable names that do not match documentation",
                             errors, "files(s) errored on download.")
      
  
     if (any(statuses == "SUCCESS")){
      save_output(output_string, type = "text")
      mdq_result$status <- "SUCCESS"
        } else if (all(statuses == "ERROR")){
          save_output(output_string, type = "text")
          mdq_result$status <- "ERROR"
        } else {
          save_output(output_string, type = "text")
          mdq_result$status <- "FAILURE"
        }
    } else {
      mdq_result <- list(output = list(list(value = "No data files to check.", type = "text")), status = "SUCCESS")
    }
  ]]></code>
  <selector>
    <name>entityNames</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
    <subSelector>
      <name>...</name>
      <xpath>./entityName</xpath>
    </subSelector>
  </selector>
  <selector>
    <name>objectNames</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
    <subSelector>
      <name>...</name>
      <xpath>./physical/objectName</xpath>
    </subSelector>
  </selector>
  <selector>
    <name>ids</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]/@id</xpath>
  </selector>
  <selector>
     <name>fieldDelimiter</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
     <subSelector>
        <name>...</name>
        <xpath>./physical/dataFormat/textFormat/simpleDelimited/fieldDelimiter</xpath>
    </subSelector>
  </selector>
  <selector>
     <name>headerLines</name>
    <xpath>/eml/dataset/*[self::dataTable|self::otherEntity]</xpath>
     <subSelector>
        <name>...</name>
        <xpath>./physical/dataFormat/textFormat/numHeaderLines</xpath>
    </subSelector>
  </selector>
  <dialect>
    <name>Ecological Metadata Language</name>
    <xpath>boolean(/*[local-name() = 'eml'])</xpath>
  </dialect>
</mdq:check>
